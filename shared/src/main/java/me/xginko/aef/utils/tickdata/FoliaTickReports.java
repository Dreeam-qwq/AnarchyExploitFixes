package me.xginko.aef.utils.tickdata;

import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import io.papermc.paper.threadedregions.RegionizedServer;
import io.papermc.paper.threadedregions.ThreadedRegionizer;
import io.papermc.paper.threadedregions.TickRegionScheduler;
import io.papermc.paper.threadedregions.TickRegions;

import java.time.Duration;

public final class FoliaTickReports implements CachedTickReports {

    private final Cache<TickRegionScheduler.RegionScheduleHandle, Double> tps_cache, mspt_cache;

    FoliaTickReports(Duration cacheTime) {
        this.tps_cache = Caffeine.newBuilder().expireAfterWrite(cacheTime).build();
        this.mspt_cache = Caffeine.newBuilder().expireAfterWrite(cacheTime).build();
    }

    @Override
    public double getGlobalTPS() {
        // Get regionhandle and check if there is already a cached tps for it
        final TickRegionScheduler.RegionScheduleHandle regionHandle = RegionizedServer.getGlobalTickData();
        Double tps = this.tps_cache.getIfPresent(regionHandle);
        if (tps == null) {
            // If nothing is cached yet, get tps and add to cache
            tps = regionHandle.getTickReport5s(System.nanoTime()).tpsData().segmentAll().average();
            this.tps_cache.put(regionHandle, tps);
        }
        return tps;
    }

    /**
     * CAUTION! THIS METHOD NEEDS TO BE CALLED EITHER FROM WITHIN AN EVENT OR AN APPROPRIATELY SCHEDULED TASK
     */
    @Override
    public double getTPS() {
        final ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData>
                currentRegion = TickRegionScheduler.getCurrentRegion();
        if (currentRegion == null) {
            return getGlobalTPS();
        }
        final TickRegionScheduler.RegionScheduleHandle regionHandle = currentRegion.getData().getRegionSchedulingHandle();
        Double tps = this.tps_cache.getIfPresent(regionHandle);
        if (tps == null) {
            tps = regionHandle.getTickReport5s(System.nanoTime()).tpsData().segmentAll().average();
            this.tps_cache.put(regionHandle, tps);
        }
        return tps;
    }

    @Override
    public double getGlobalMSPT() {
        final TickRegionScheduler.RegionScheduleHandle regionHandle = RegionizedServer.getGlobalTickData();
        Double mspt = this.mspt_cache.getIfPresent(regionHandle);
        if (mspt == null) {
            mspt = regionHandle.getTickReport5s(System.nanoTime()).timePerTickData().segmentAll().average() / 1000000;
            this.mspt_cache.put(regionHandle, mspt);
        }
        return mspt;
    }

    /**
     * CAUTION! THIS METHOD NEEDS TO BE CALLED EITHER FROM WITHIN AN EVENT OR AN APPROPRIATELY SCHEDULED TASK
     */
    @Override
    public double getMSPT() {
        final ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData>
                currentRegion = TickRegionScheduler.getCurrentRegion();
        if (currentRegion == null) {
            return getGlobalTPS();
        }
        final TickRegionScheduler.RegionScheduleHandle regionHandle = currentRegion.getData().getRegionSchedulingHandle();
        Double mspt = this.mspt_cache.getIfPresent(regionHandle);
        if (mspt == null) {
            mspt = regionHandle.getTickReport5s(System.nanoTime()).timePerTickData().segmentAll().average() / 1000000;
            this.mspt_cache.put(regionHandle, mspt);
        }
        return mspt;
    }
}
