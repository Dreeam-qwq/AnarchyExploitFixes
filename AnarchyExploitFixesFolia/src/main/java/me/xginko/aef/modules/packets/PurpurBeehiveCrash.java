package me.xginko.aef.modules.packets;

import com.github.retrooper.packetevents.PacketEvents;
import com.github.retrooper.packetevents.event.PacketListenerPriority;
import com.github.retrooper.packetevents.event.PacketReceiveEvent;
import com.github.retrooper.packetevents.protocol.packettype.PacketType;
import com.github.retrooper.packetevents.wrapper.play.client.WrapperPlayClientPluginMessage;
import com.google.common.io.ByteStreams;
import org.bukkit.Location;
import org.bukkit.entity.Player;
import org.bukkit.util.NumberConversions;

public class PurpurBeehiveCrash extends AEFPacketModule {

    private static final String BEEHIVE_C2S_CHANNEL = "purpur:beehive_c2s";
    private static final int SIZE_BITS_X = 26;
    private static final int SIZE_BITS_Z = SIZE_BITS_X;
    private static final int SIZE_BITS_Y = 64 - SIZE_BITS_X - SIZE_BITS_Z;
    private static final int BIT_SHIFT_Z = SIZE_BITS_Y;
    private static final int BIT_SHIFT_X = SIZE_BITS_Y + SIZE_BITS_Z;

    private final double maxDistanceSquared;
    private final boolean log, kick;

    public PurpurBeehiveCrash() {
        super("patches.beehive-crash-patch", PacketListenerPriority.HIGHEST);
        config.addComment(configPath + ".enable", """
                Patches a server crash exploit exclusive to Purpur servers.\s
                This exploit works due to PurpurClient having a feature that lets clients\s
                request stored data of a clicked beehive from the server.\s
                The server does not check how far the clicked beehive is away from the client\s
                enabling a malicious sender to load chunks very fast at far away locations by\s
                telling the server it clicked a beehive there.""");
        this.maxDistanceSquared = NumberConversions.square(config.getInt(configPath + ".max-distance", 24));
        this.log = config.getBoolean(configPath + ".log", false);
        this.kick = config.getBoolean(configPath + ".kick-player", false);
    }

    @Override
    public void enable() {
        PacketEvents.getAPI().getEventManager().registerListener(abstractListener);
    }

    @Override
    public void disable() {
        PacketEvents.getAPI().getEventManager().unregisterListener(abstractListener);
    }

    @Override
    public boolean shouldEnable() {
        return config.getBoolean(configPath + ".enable", true);
    }

    @Override
    public void onPacketReceive(PacketReceiveEvent event) {
        if (event.getPacketType() != PacketType.Play.Client.PLUGIN_MESSAGE) return;
        WrapperPlayClientPluginMessage packet = new WrapperPlayClientPluginMessage(event);
        if (!packet.getChannelName().equalsIgnoreCase(BEEHIVE_C2S_CHANNEL)) return;

        Player player = (Player) event.getPlayer();
        if (player == null) return;

        if (distanceSquared(ByteStreams.newDataInput(packet.getData()).readLong(), player.getLocation()) > maxDistanceSquared) {
            event.setCancelled(true);
            onCancel(log, kick, event.getUser());
        }
    }

    private double distanceSquared(long packedPos, final Location playerPos) {
        return  NumberConversions.square(unpackLongX(packedPos) - playerPos.getX()) +
                NumberConversions.square(unpackLongY(packedPos) - playerPos.getY()) +
                NumberConversions.square(unpackLongZ(packedPos) - playerPos.getZ());
    }

    private int unpackLongX(long packedPos) {
        return (int)(packedPos << 64 - BIT_SHIFT_X - SIZE_BITS_X >> 64 - SIZE_BITS_X);
    }

    private int unpackLongY(long packedPos) {
        return (int)(packedPos << 64 - SIZE_BITS_Y >> 64 - SIZE_BITS_Y);
    }

    private int unpackLongZ(long packedPos) {
        return (int)(packedPos << 64 - BIT_SHIFT_Z - SIZE_BITS_Z >> 64 - SIZE_BITS_Z);
    }
}
