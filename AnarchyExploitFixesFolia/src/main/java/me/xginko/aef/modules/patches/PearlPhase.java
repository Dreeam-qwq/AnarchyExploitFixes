package me.xginko.aef.modules.patches;

import com.cryptomorin.xseries.XMaterial;
import me.xginko.aef.AnarchyExploitFixes;
import me.xginko.aef.modules.AEFModule;
import org.bukkit.Location;
import org.bukkit.block.Block;
import org.bukkit.block.BlockFace;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.HandlerList;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerTeleportEvent;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

public class PearlPhase extends AEFModule implements Listener {

    private final int radius;
    private final long timeoutMillis;

    public PearlPhase() {
        super("patches.pearl-phase");
        config.addComment(configPath+ ".enable",
                "Attempts to patch a pearl phasing exploit by cancelling the teleport\n" +
                        "if the pearl is thrown at or near a cobweb.");
        this.radius = config.getInt(configPath + ".cobweb-block-radius", 2,
                "How many blocks around the teleport location should be searched\n" +
                        "for cobwebs if the teleport location isn't one itself.");
        this.timeoutMillis = config.getInt(configPath + ".check-timeout-millis", 1000,
                "We will have to schedule the check on folia, meaning theres a chance\n" +
                        "the task might take longer than expected. To make sure that does not cause\n" +
                        "more lag, we set a time limit here.\n" +
                        "Only relevant on folia.");
    }

    @Override
    public boolean shouldEnable() {
        return config.getBoolean(configPath+".enable", false);
    }

    @Override
    public void enable() {
        plugin.getServer().getPluginManager().registerEvents(this, plugin);
    }

    @Override
    public void disable() {
        HandlerList.unregisterAll(this);
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    private void onPlayerTeleport(PlayerTeleportEvent event) {
        if (event.getCause() != PlayerTeleportEvent.TeleportCause.ENDER_PEARL) return;

        Location destination = event.getTo();

        if (!AnarchyExploitFixes.isServerFolia()) {
            if (isWebbed(destination))
                event.setCancelled(true);
            return;
        }

        try {
            CompletableFuture<Boolean> future = new CompletableFuture<>();
            // We will have to schedule the check on folia because the event might not
            // fire from the same thread as the region of the destination location.
            plugin.getServer().getRegionScheduler().execute(plugin, destination, () ->
                    future.complete(isWebbed(destination)));
            if (future.get(timeoutMillis, TimeUnit.MILLISECONDS))
                event.setCancelled(true);
        } catch (ExecutionException | InterruptedException | TimeoutException e) {
            error("Error while checking if the destination is a cobweb.", e);
        }
    }

    private boolean isWebbed(Location location) {
        Block destBlock = location.getBlock();

        if (destBlock.getType() == XMaterial.COBWEB.parseMaterial()) {
            return true;
        }

        for (BlockFace blockFace : BlockFace.values()) {
            for (int i = 1; i < radius+1; i++) {
                if (destBlock.getRelative(blockFace).getType() == XMaterial.COBWEB.parseMaterial()) {
                    return true;
                }
            }
        }

        return false;
    }
}
