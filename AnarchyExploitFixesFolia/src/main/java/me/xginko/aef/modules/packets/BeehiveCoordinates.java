package me.xginko.aef.modules.packets;

import com.github.retrooper.packetevents.PacketEvents;
import com.github.retrooper.packetevents.event.PacketListenerPriority;
import com.github.retrooper.packetevents.event.PacketSendEvent;
import com.github.retrooper.packetevents.protocol.item.ItemStack;
import com.github.retrooper.packetevents.protocol.nbt.NBTCompound;
import com.github.retrooper.packetevents.protocol.nbt.NBTList;
import com.github.retrooper.packetevents.protocol.packettype.PacketType;
import com.github.retrooper.packetevents.wrapper.play.server.WrapperPlayServerSetSlot;
import me.xginko.aef.AnarchyExploitFixes;
import me.xginko.aef.config.Config;

import java.util.Arrays;
import java.util.List;

public class BeehiveCoordinates extends AEFPacketModule {

    private final String[] entityDataTagsToRemove;

    public BeehiveCoordinates() {
        super(PacketListenerPriority.HIGHEST);
        shouldEnable();
        Config config = AnarchyExploitFixes.getConfiguration();
        config.addComment(configPath() + ".enable",
                "Patches an exploit that allows players to obtain another player's coordinates\n" +
                "by trading them for beehives or beenests.\n" +
                "If the traded item contains any bees, the stored bee's NBT data could then be read from the item.\n" +
                "This data includes, but is not limited to:\n" +
                " - UID of the world the bee was first spawned into existence\n" +
                " - XYZ coordinates of where the bee was first spawned into existence\n" +
                " - XYZ coordinates of where the bee last visited a flower\n" +
                " - XYZ coordinates of where the bee has its hive\n" +
                " - XYZ of the bee's last coordinates before entering it's hive");
        final List<String> tags = config.getList(configPath() + ".tags",
                Arrays.asList("Pos", "HivePos", "FlowerPos", "Paper.Origin", "Paper.OriginWorld", "WorldUUIDMost", "WorldUUIDLeast"),
                "The NBT tags to filter from the item. These are the Keys that hold the position data.\n" +
                        "You may add more tags you want removed here.");
        this.entityDataTagsToRemove = new String[tags.size()];
        for (int i = 0; i < tags.size(); i++) {
            entityDataTagsToRemove[i] = tags.get(i);
        }
    }

    @Override
    public String configPath() {
        return "patches.remove-beehive-coordinates";
    }

    @Override
    public void enable() {
        PacketEvents.getAPI().getEventManager().registerListener(this);
    }

    @Override
    public boolean shouldEnable() {
        return AnarchyExploitFixes.getConfiguration().getBoolean(configPath() + ".enable", true);
    }

    @Override
    public void disable() {
        PacketEvents.getAPI().getEventManager().unregisterListener(this);
    }

    @Override
    public void onPacketSend(PacketSendEvent event) {
        if (event.getPacketType() != PacketType.Play.Server.SET_SLOT) return;
        WrapperPlayServerSetSlot packet = new WrapperPlayServerSetSlot(event);
        ItemStack filtered = filterItemStack(packet.getItem());
        if (filtered == null) return;
        packet.setItem(filtered);
        event.markForReEncode(true);
    }

    private ItemStack filterItemStack(ItemStack itemStack) {
        if (itemStack == null || itemStack.isEmpty()) return null;
        final NBTCompound rootCompound = itemStack.getNBT();
        if (!filterCompound(rootCompound)) return null;
        itemStack.setNBT(rootCompound);
        return itemStack;
    }

    private boolean filterCompound(NBTCompound compound) {
        if (compound == null || compound.isEmpty()) return false;

        boolean needsReEncode = false;

        if (compound.getTags().containsKey("Bees")) {
            NBTList<NBTCompound> bees = compound.getCompoundListTagOrNull("Bees");
            if (bees == null || bees.isEmpty()) return needsReEncode;

            for (int i = 0; i < bees.size(); i++) {
                NBTCompound beeEntity = bees.getTag(i);
                NBTCompound beeEntityData = beeEntity.getCompoundTagOrNull("EntityData");
                if (beeEntityData != null) {
                    for (String toRemove : entityDataTagsToRemove) {
                        if (beeEntityData.removeTag(toRemove) != null) {
                            needsReEncode = true;
                        }
                    }
                    if (needsReEncode)
                        beeEntity.setTag("EntityData", beeEntityData);
                }
                if (needsReEncode)
                    bees.setTag(i, beeEntity);
            }

            if (needsReEncode)
                compound.setTag("Bees", bees);
        }

        if (compound.getTags().containsKey("Items")) {
            NBTList<NBTCompound> items = compound.getCompoundListTagOrNull("Items");
            if (items == null || items.isEmpty()) return needsReEncode;

            for (int i = 0; i < items.size(); i++) {
                NBTCompound item = items.getTag(i);
                NBTCompound itemRootCompound = item.getCompoundTagOrNull("tag");
                if (filterCompound(itemRootCompound)) {
                    items.setTag(i, item);
                    needsReEncode = true;
                }
            }

            if (needsReEncode)
                compound.setTag("Items", items);
        }

        if (compound.getTags().containsKey("BlockEntityTag")) {
            NBTCompound blockEntityTag = compound.getCompoundTagOrNull("BlockEntityTag");
            if (filterCompound(blockEntityTag)) {
                compound.setTag("BlockEntityTag", blockEntityTag);
                needsReEncode = true;
            }
        }

        return needsReEncode;
    }
}
