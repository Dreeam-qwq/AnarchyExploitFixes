package me.xginko.aef.modules.packets;

import com.github.retrooper.packetevents.PacketEvents;
import com.github.retrooper.packetevents.event.PacketListenerPriority;
import com.github.retrooper.packetevents.event.PacketSendEvent;
import com.github.retrooper.packetevents.protocol.item.ItemStack;
import com.github.retrooper.packetevents.protocol.nbt.NBTCompound;
import com.github.retrooper.packetevents.protocol.nbt.NBTList;
import com.github.retrooper.packetevents.protocol.packettype.PacketType;
import com.github.retrooper.packetevents.wrapper.play.server.WrapperPlayServerSetSlot;

import java.util.List;

public class BeehiveCoordinates extends AEFPacketModule {

    private final String[] entityDataTagsToRemove;

    public BeehiveCoordinates() {
        super("patches.remove-beehive-coordinates", PacketListenerPriority.HIGHEST);
        config.addComment(configPath + ".enable", """
                        Patches an exploit that allows players to obtain another player's coordinates\s
                        by trading them for Beehives or Beenests.\s
                        If the traded item contains any bees, the stored bee's NBT data could then be read from the item.\s
                        This data includes, but is not limited to:\s
                         - UID of the world the bee was first spawned into existence\s
                         - XYZ coordinates of where the bee was first spawned into existence\s
                         - XYZ coordinates of where the bee last visited a flower\s
                         - XYZ coordinates of where the bee has its hive\s
                         - XYZ of the bee's last coordinates before entering it's hive""");
        final List<String> tags = config.getList(configPath + ".tags",
                List.of("Pos", "HivePos", "FlowerPos", "Paper.Origin", "Paper.OriginWorld", "WorldUUIDMost", "WorldUUIDLeast"), """
                        The NBT tags to filter from the item. These are the Keys that hold the position data.\s
                        You may add more tags you want removed here.""");
        this.entityDataTagsToRemove = new String[tags.size()];
        for (int i = 0; i < tags.size(); i++) {
            entityDataTagsToRemove[i] = tags.get(i);
        }
    }

    @Override
    public void enable() {
        PacketEvents.getAPI().getEventManager().registerListener(abstractListener);
    }

    @Override
    public boolean shouldEnable() {
        return config.getBoolean(configPath + ".enable", true);
    }

    @Override
    public void disable() {
        PacketEvents.getAPI().getEventManager().unregisterListener(abstractListener);
    }

    @Override
    public void onPacketSend(PacketSendEvent event) {
        if (event.getPacketType() != PacketType.Play.Server.SET_SLOT) return;
        WrapperPlayServerSetSlot packet = new WrapperPlayServerSetSlot(event);
        ItemStack filtered = filterItemStack(packet.getItem());
        if (filtered == null) return;
        packet.setItem(filtered);
        event.markForReEncode(true);
    }

    private ItemStack filterItemStack(ItemStack itemStack) {
        if (itemStack == null || itemStack.isEmpty()) return null;
        final NBTCompound rootCompound = itemStack.getNBT();
        if (!filterCompound(rootCompound)) return null;
        itemStack.setNBT(rootCompound);
        return itemStack;
    }

    private boolean filterCompound(NBTCompound compound) {
        if (compound == null || compound.isEmpty()) return false;

        boolean needsReEncode = false;

        if (compound.getTags().containsKey("Bees")) {
            NBTList<NBTCompound> bees = compound.getCompoundListTagOrNull("Bees");
            if (bees == null || bees.isEmpty()) return needsReEncode;

            for (int i = 0; i < bees.size(); i++) {
                NBTCompound beeEntity = bees.getTag(i);
                NBTCompound beeEntityData = beeEntity.getCompoundTagOrNull("EntityData");
                if (beeEntityData != null) {
                    for (String toRemove : entityDataTagsToRemove) {
                        if (beeEntityData.removeTag(toRemove) != null) {
                            needsReEncode = true;
                        }
                    }
                    if (needsReEncode)
                        beeEntity.setTag("EntityData", beeEntityData);
                }
                if (needsReEncode)
                    bees.setTag(i, beeEntity);
            }

            if (needsReEncode)
                compound.setTag("Bees", bees);
        }

        if (compound.getTags().containsKey("Items")) {
            NBTList<NBTCompound> items = compound.getCompoundListTagOrNull("Items");
            if (items == null || items.isEmpty()) return needsReEncode;

            for (int i = 0; i < items.size(); i++) {
                NBTCompound item = items.getTag(i);
                NBTCompound itemRootCompound = item.getCompoundTagOrNull("tag");
                if (filterCompound(itemRootCompound)) {
                    items.setTag(i, item);
                    needsReEncode = true;
                }
            }

            if (needsReEncode)
                compound.setTag("Items", items);
        }

        if (compound.getTags().containsKey("BlockEntityTag")) {
            NBTCompound blockEntityTag = compound.getCompoundTagOrNull("BlockEntityTag");
            if (filterCompound(blockEntityTag)) {
                compound.setTag("BlockEntityTag", blockEntityTag);
                needsReEncode = true;
            }
        }

        return needsReEncode;
    }
}
