package me.xginko.aef.modules.illegals.items;

import com.destroystokyo.paper.event.player.PlayerArmorChangeEvent;
import io.papermc.paper.event.player.PrePlayerAttackEntityEvent;
import me.xginko.aef.enums.AEFPermission;
import me.xginko.aef.enums.IllegalHandling;
import me.xginko.aef.enums.ItemLegality;
import me.xginko.aef.modules.AEFModule;
import me.xginko.aef.utils.CachingPermTool;
import me.xginko.aef.utils.EntityUtil;
import org.bukkit.entity.EntityType;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.HandlerList;
import org.bukkit.event.Listener;
import org.bukkit.event.block.BlockDispenseEvent;
import org.bukkit.event.entity.EntityDamageByEntityEvent;
import org.bukkit.event.inventory.InventoryClickEvent;
import org.bukkit.event.inventory.InventoryInteractEvent;
import org.bukkit.event.inventory.InventoryMoveItemEvent;
import org.bukkit.event.inventory.InventoryOpenEvent;
import org.bukkit.event.player.PlayerAttemptPickupItemEvent;
import org.bukkit.event.player.PlayerDropItemEvent;
import org.bukkit.event.player.PlayerInteractEntityEvent;
import org.bukkit.event.player.PlayerInteractEvent;
import org.bukkit.event.player.PlayerItemConsumeEvent;
import org.bukkit.inventory.InventoryHolder;
import org.bukkit.inventory.ItemStack;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import java.util.stream.Collectors;

public abstract class IllegalItemModule extends AEFModule implements Listener {

    public abstract ItemLegality legalityOf(ItemStack itemStack);
    public abstract void handleItem(ItemStack itemStack, ItemLegality legality);

    protected final AEFPermission bypassPermission;
    protected final IllegalHandling handling;
    protected final Set<Listener> optionalListeners;

    public IllegalItemModule(String configPath, AEFPermission bypassPermission) {
        super(configPath);
        this.bypassPermission = bypassPermission;
        this.optionalListeners = new HashSet<>(2);

        String configuredHandling = config.getString(configPath + ".handling", IllegalHandling.PREVENT_USE_ONLY.name(),
                "Available options:\n" + Arrays.stream(IllegalHandling.values())
                        .map(option -> option.name() + " - " + option.description())
                        .collect(Collectors.joining("\n")));
        IllegalHandling handling;
        try {
            handling = IllegalHandling.valueOf(configuredHandling);
        } catch (IllegalArgumentException e) {
            handling = IllegalHandling.PREVENT_USE_ONLY;
            warn("Handling option '" + configuredHandling + "' not recognized. Defaulting to " + handling.name());
        }
        this.handling = handling;

        if (this.handling == IllegalHandling.STRICT) {
            optionalListeners.add(new Listener() {
                @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
                private void onInventoryOpen(InventoryOpenEvent event) {
                    if (CachingPermTool.hasPermission(bypassPermission, event.getPlayer())) return;

                    for (ItemStack invItem : event.getInventory()) {
                        handleItem(invItem, legalityOf(invItem));
                    }
                }
            });
        }

        if (config.getBoolean(configPath + ".prevent-hopper32k-mechanic", false, """
                Prevents Hopper32k mechanic of placing a shulker containing illegals\s
                on top of a hopper, then using the illegal out of the hoppers inventory.\s
                WARNING: Hooks into InventoryMoveItemEvent, which can become VERY resource\s
                intense as the event fires for every single item getting moved by the\s
                hopper. Enable only if you need to.""")) {
            optionalListeners.add(new Listener() {
                @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
                private void onItemGoesThroughHopper(InventoryMoveItemEvent event) {
                    if (legalityOf(event.getItem()) != ItemLegality.LEGAL) {
                        event.setCancelled(true);
                    }
                }
            });
        }
    }

    @Override
    public void enable() {
        plugin.getServer().getPluginManager().registerEvents(this, plugin);
        optionalListeners.forEach(optional -> plugin.getServer().getPluginManager().registerEvents(optional, plugin));
    }

    @Override
    public void disable() {
        HandlerList.unregisterAll(this);
        optionalListeners.forEach(HandlerList::unregisterAll);
        optionalListeners.clear();
    }

    public ItemLegality legalityOf(Iterable<ItemStack> itemStacks) {
        if (itemStacks == null) {
            return ItemLegality.LEGAL;
        }

        for (ItemStack itemStack : itemStacks) {
            if (legalityOf(itemStack) != ItemLegality.LEGAL) {
                return ItemLegality.CONTAINS_ILLEGAL;
            }
        }

        return ItemLegality.LEGAL;
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    public void onPlayerItemConsume(PlayerItemConsumeEvent event) {
        if (legalityOf(event.getItem()) != ItemLegality.LEGAL) {
            event.setCancelled(true);
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    public void onBlockDispense(BlockDispenseEvent event) {
        if (legalityOf(event.getItem()) != ItemLegality.LEGAL) {
            event.setCancelled(true);
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    public void onPlayerArmorChange(PlayerArmorChangeEvent event) {
        if (!CachingPermTool.hasPermission(bypassPermission, event.getPlayer())) {
            handleItem(event.getNewItem(), legalityOf(event.getNewItem()));
            handleItem(event.getOldItem(), legalityOf(event.getOldItem()));
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    public void onInventoryClick(InventoryClickEvent event) {
        if (CachingPermTool.hasPermission(bypassPermission, event.getWhoClicked())) return;

        ItemLegality clickedLegality = legalityOf(event.getCurrentItem());
        if (clickedLegality != ItemLegality.LEGAL) {
            event.setCancelled(true);
            handleItem(event.getCurrentItem(), clickedLegality);
        }

        ItemLegality cursorLegality = legalityOf(event.getCursor());
        if (cursorLegality != ItemLegality.LEGAL) {
            event.setCancelled(true);
            handleItem(event.getCursor(), cursorLegality);
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    public void onInventoryInteract(InventoryInteractEvent event) {
        if (CachingPermTool.hasPermission(bypassPermission, event.getWhoClicked())) return;

        for (ItemStack invItem : event.getInventory()) {
            ItemLegality invItemLegality = legalityOf(invItem);
            if (invItemLegality != ItemLegality.LEGAL) {
                event.setCancelled(true);
                handleItem(invItem, invItemLegality);
            }
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    public void onPrePlayerAttackEntity(PrePlayerAttackEntityEvent event) {
        ItemStack mainHandItem = event.getPlayer().getInventory().getItemInMainHand();
        final ItemLegality mainHandLegality = legalityOf(mainHandItem);
        if (mainHandLegality != ItemLegality.LEGAL && !CachingPermTool.hasPermission(bypassPermission, event.getPlayer())) {
            event.setCancelled(true);
            handleItem(mainHandItem, mainHandLegality);
        }

        ItemStack offHandItem = event.getPlayer().getInventory().getItemInOffHand();
        final ItemLegality offHandLegality = legalityOf(offHandItem);
        if (offHandLegality != ItemLegality.LEGAL && !CachingPermTool.hasPermission(bypassPermission, event.getPlayer())) {
            event.setCancelled(true);
            handleItem(offHandItem, offHandLegality);
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    public void onEntityDamageByEntity(EntityDamageByEntityEvent event) {
        if (event.getDamager().getType() == EntityType.PLAYER) {
            final Player player = (Player) event.getDamager();

            ItemStack mainHandItem = player.getInventory().getItemInMainHand();
            final ItemLegality mainHandLegality = legalityOf(mainHandItem);
            if (mainHandLegality != ItemLegality.LEGAL && !CachingPermTool.hasPermission(bypassPermission, player)) {
                event.setCancelled(true);
                handleItem(mainHandItem, mainHandLegality);
            }

            ItemStack offHandItem = player.getInventory().getItemInOffHand();
            final ItemLegality offHandLegality = legalityOf(offHandItem);
            if (offHandLegality != ItemLegality.LEGAL && !CachingPermTool.hasPermission(bypassPermission, player)) {
                event.setCancelled(true);
                handleItem(offHandItem, offHandLegality);
            }
            return;
        }

        if (EntityUtil.isInventoryHolder(event.getDamager())) {
            if (legalityOf(((InventoryHolder) event.getDamager()).getInventory()) != ItemLegality.LEGAL) {
                event.setCancelled(true);
            }
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    public void onPlayerAttemptPickupItem(PlayerAttemptPickupItemEvent event) {
        ItemStack pickUpItem = event.getItem().getItemStack();
        final ItemLegality legality = legalityOf(pickUpItem);
        if (legality != ItemLegality.LEGAL && !CachingPermTool.hasPermission(bypassPermission, event.getPlayer())) {
            event.setCancelled(true);
            handleItem(pickUpItem, legality);
            event.getItem().setItemStack(pickUpItem);
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    public void onPlayerDropItem(PlayerDropItemEvent event) {
        ItemStack droppedItem = event.getItemDrop().getItemStack();
        final ItemLegality legality = legalityOf(droppedItem);
        if (legality != ItemLegality.LEGAL && !CachingPermTool.hasPermission(bypassPermission, event.getPlayer())) {
            handleItem(droppedItem, legality);
            event.getItemDrop().setItemStack(droppedItem);
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = false)
    public void onPlayerInteract(PlayerInteractEvent event) {
        ItemStack interactItem = event.getItem();
        final ItemLegality legality = legalityOf(interactItem);
        if (legality != ItemLegality.LEGAL && !CachingPermTool.hasPermission(bypassPermission, event.getPlayer())) {
            event.setCancelled(true);
            handleItem(interactItem, legality);
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    public void onPlayerInteractEntity(PlayerInteractEntityEvent event) {
        ItemStack handItem = event.getPlayer().getInventory().getItem(event.getHand());
        final ItemLegality legality = legalityOf(handItem);
        if (legality != ItemLegality.LEGAL && !CachingPermTool.hasPermission(bypassPermission, event.getPlayer())) {
            event.setCancelled(true);
            handleItem(handItem, legality);
        }
    }
}
