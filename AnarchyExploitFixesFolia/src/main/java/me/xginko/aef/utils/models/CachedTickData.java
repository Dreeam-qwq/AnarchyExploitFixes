package me.xginko.aef.utils.models;

import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import io.papermc.paper.threadedregions.RegionizedServer;
import io.papermc.paper.threadedregions.ThreadedRegionizer;
import io.papermc.paper.threadedregions.TickRegionScheduler;
import io.papermc.paper.threadedregions.TickRegions;
import me.xginko.aef.AnarchyExploitFixes;
import org.bukkit.Server;
import org.bukkit.plugin.java.JavaPlugin;
import org.jetbrains.annotations.NotNull;

import java.time.Duration;

public interface CachedTickData {

    double getGlobalTPS();
    double getTPS();
    double getGlobalMSPT();
    double getMSPT();

    static @NotNull CachedTickData create(Duration cacheTime) {
        if (AnarchyExploitFixes.isServerFolia()) {
            return new Folia(cacheTime);
        } else {
            return new Default(AnarchyExploitFixes.getInstance(), cacheTime);
        }
    }

    final class Default implements CachedTickData {

        private final Server server;
        private final Cache<Boolean, Double> cache;

        Default(JavaPlugin plugin, Duration cacheTime) {
            this.server = plugin.getServer();
            this.cache = Caffeine.newBuilder().expireAfterWrite(cacheTime).build();
        }

        @Override
        public double getGlobalTPS() {
            Double tps = this.cache.getIfPresent(true);
            if (tps == null) {
                tps = this.server.getTPS()[0];
                this.cache.put(true, tps);
            }
            return tps;
        }

        @Override
        public double getTPS() {
            return getGlobalTPS();
        }

        @Override
        public double getGlobalMSPT() {
            Double mspt = this.cache.getIfPresent(false);
            if (mspt == null) {
                mspt = this.server.getAverageTickTime();
                this.cache.put(false, mspt);
            }
            return mspt;
        }

        @Override
        public double getMSPT() {
            return getGlobalMSPT();
        }
    }

    final class Folia implements CachedTickData {

        private final Cache<TickRegionScheduler.RegionScheduleHandle, Double> tps_cache, mspt_cache;

        Folia(Duration cacheTime) {
            this.tps_cache = Caffeine.newBuilder().expireAfterWrite(cacheTime).build();
            this.mspt_cache = Caffeine.newBuilder().expireAfterWrite(cacheTime).build();
        }

        @Override
        public double getGlobalTPS() {
            // Get regionhandle and check if there is already a cached tps for it
            final TickRegionScheduler.RegionScheduleHandle regionHandle = RegionizedServer.getGlobalTickData();
            Double tps = this.tps_cache.getIfPresent(regionHandle);
            if (tps == null) {
                // If nothing is cached yet, get tps and add to cache
                tps = regionHandle.getTickReport5s(System.nanoTime()).tpsData().segmentAll().average();
                this.tps_cache.put(regionHandle, tps);
            }
            return tps;
        }

        /**
         *   CAUTION! THIS METHOD NEEDS TO BE CALLED WITH THREAD CONTEXT
         */
        @Override
        public double getTPS() {
            final ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData>
                    currentRegion = TickRegionScheduler.getCurrentRegion();
            if (currentRegion == null) {
                return getGlobalTPS();
            }
            final TickRegionScheduler.RegionScheduleHandle regionHandle = currentRegion.getData().getRegionSchedulingHandle();
            Double tps = this.tps_cache.getIfPresent(regionHandle);
            if (tps == null) {
                tps = regionHandle.getTickReport5s(System.nanoTime()).tpsData().segmentAll().average();
                this.tps_cache.put(regionHandle, tps);
            }
            return tps;
        }

        @Override
        public double getGlobalMSPT() {
            final TickRegionScheduler.RegionScheduleHandle regionHandle = RegionizedServer.getGlobalTickData();
            Double mspt = this.mspt_cache.getIfPresent(regionHandle);
            if (mspt == null) {
                mspt = regionHandle.getTickReport5s(System.nanoTime()).timePerTickData().segmentAll().average() / 1000000;
                this.mspt_cache.put(regionHandle, mspt);
            }
            return mspt;
        }

        /**
         *   CAUTION! THIS METHOD NEEDS TO BE CALLED WITH THREAD CONTEXT
         */
        @Override
        public double getMSPT() {
            final ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData>
                    currentRegion = TickRegionScheduler.getCurrentRegion();
            if (currentRegion == null) {
                return getGlobalTPS();
            }
            final TickRegionScheduler.RegionScheduleHandle regionHandle = currentRegion.getData().getRegionSchedulingHandle();
            Double mspt = this.mspt_cache.getIfPresent(regionHandle);
            if (mspt == null) {
                mspt = regionHandle.getTickReport5s(System.nanoTime()).timePerTickData().segmentAll().average() / 1000000;
                this.mspt_cache.put(regionHandle, mspt);
            }
            return mspt;
        }
    }
}