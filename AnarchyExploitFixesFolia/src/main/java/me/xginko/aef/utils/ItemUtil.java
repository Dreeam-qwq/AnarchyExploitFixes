package me.xginko.aef.utils;

import de.tr7zw.changeme.nbtapi.NBTItem;
import net.kyori.adventure.text.minimessage.MiniMessage;
import org.bukkit.inventory.InventoryHolder;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.BlockStateMeta;
import org.bukkit.inventory.meta.BookMeta;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.nio.charset.StandardCharsets;

public class ItemUtil {

    public static @Nullable Iterable<ItemStack> getStoredItems(@NotNull ItemStack itemStack) {
        if (MaterialUtil.INVENTORY_HOLDER_BLOCKS.contains(itemStack.getType())) {
            return ((InventoryHolder) ((BlockStateMeta) itemStack.getItemMeta()).getBlockState()).getInventory();
        }
        return BundleUtil.canCheckBundles() ? BundleUtil.getItems(itemStack) : null;
    }

    public static int getApproximateByteSize(@Nullable ItemStack itemStack, boolean utf16) {
        if (itemStack == null || !itemStack.hasItemMeta())
            return 0;
        Iterable<ItemStack> stored = getStoredItems(itemStack);
        if (stored != null) {
            return getApproximateByteSize(stored, utf16);
        }
        if (MaterialUtil.isBook(itemStack.getType())) {
            return getApproximateByteSize((BookMeta) itemStack.getItemMeta(), utf16);
        }
        return new NBTItem(itemStack).toString().getBytes(utf16 ? StandardCharsets.UTF_16 : StandardCharsets.UTF_8).length;
    }

    public static int getApproximateByteSize(@Nullable Iterable<ItemStack> inventory, boolean utf16) {
        if (inventory == null)
            return 0;
        int collectiveSize = 0;
        for (ItemStack stack : inventory) {
            collectiveSize += getApproximateByteSize(stack, utf16);
        }
        return collectiveSize;
    }

    @SuppressWarnings("DataFlowIssue") // Legitimate because we make sure no values are null by testing .hasX()
    public static int getApproximateByteSize(@NotNull BookMeta bookMeta, boolean utf16) {
        StringBuilder content = new StringBuilder();
        if (bookMeta.hasPages())
            bookMeta.pages().stream().map(page -> MiniMessage.miniMessage().serialize(page)).forEach(content::append);
        if (bookMeta.hasTitle())
            content.append(MiniMessage.miniMessage().serialize(bookMeta.title()));
        if (bookMeta.hasAuthor())
            content.append(MiniMessage.miniMessage().serialize(bookMeta.author()));
        if (bookMeta.hasLore())
            bookMeta.lore().stream().map(loreLine -> MiniMessage.miniMessage().serialize(loreLine)).forEach(content::append);
        return content.toString().getBytes(utf16 ? StandardCharsets.UTF_16 : StandardCharsets.UTF_8).length;
    }
}
