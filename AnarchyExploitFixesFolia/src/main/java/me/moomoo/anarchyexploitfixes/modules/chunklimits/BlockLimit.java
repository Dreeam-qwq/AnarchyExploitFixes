package me.moomoo.anarchyexploitfixes.modules.chunklimits;

import io.github.thatsmusic99.configurationmaster.api.ConfigSection;
import me.moomoo.anarchyexploitfixes.AnarchyExploitFixes;
import me.moomoo.anarchyexploitfixes.modules.AEFModule;
import org.bukkit.Chunk;
import org.bukkit.Material;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.HandlerList;
import org.bukkit.event.Listener;
import org.bukkit.event.block.BlockPlaceEvent;

import java.util.EnumMap;
import java.util.Map;
import java.util.TreeMap;

public class BlockLimit implements AEFModule, Listener {

    private final Map<Material, Integer> blockLimits = new EnumMap<>(Material.class);

    public BlockLimit() {
        shouldEnable();

        Map<String, Object> defaults = new TreeMap<>();
        defaults.put("ENCHANTING_TABLE", 16);
        defaults.put("ENDER_CHEST", 64);
        defaults.put("CHEST", 500);
        defaults.put("DISPENSER", 100);
        defaults.put("TRAPPED_CHEST", 200);
        defaults.put("SLIME_BLOCK", 128);
        defaults.put("BEACON", 32);
        defaults.put("PISTON", 32);
        defaults.put("STICKY_PISTON", 32);
        defaults.put("MOVING_PISTON", 32);
        defaults.put("PISTON_HEAD", 32);
        defaults.put("GLOWSTONE", 5000);
        // Skull items
        defaults.put("CREEPER_HEAD", 16);
        defaults.put("CREEPER_WALL_HEAD", 16);
        defaults.put("DRAGON_HEAD", 16);
        defaults.put("DRAGON_WALL_HEAD", 16);
        defaults.put("PIGLIN_HEAD", 16);
        defaults.put("PIGLIN_WALL_HEAD", 16);
        defaults.put("PLAYER_HEAD", 16);
        defaults.put("PLAYER_WALL_HEAD", 16);
        defaults.put("ZOMBIE_HEAD", 16);
        defaults.put("ZOMBIE_WALL_HEAD", 16);
        // Signs
        defaults.put("ACACIA_HANGING_SIGN", 8);
        defaults.put("ACACIA_SIGN", 8);
        defaults.put("ACACIA_WALL_HANGING_SIGN", 8);
        defaults.put("ACACIA_WALL_SIGN", 8);
        defaults.put("BAMBOO_HANGING_SIGN", 8);
        defaults.put("BAMBOO_SIGN", 8);
        defaults.put("BAMBOO_WALL_HANGING_SIGN", 8);
        defaults.put("BAMBOO_WALL_SIGN", 8);
        defaults.put("BIRCH_HANGING_SIGN", 8);
        defaults.put("BIRCH_SIGN", 8);
        defaults.put("BIRCH_WALL_HANGING_SIGN", 8);
        defaults.put("BIRCH_WALL_SIGN", 8);
        defaults.put("CRIMSON_HANGING_SIGN", 8);
        defaults.put("CRIMSON_SIGN", 8);
        defaults.put("CRIMSON_WALL_HANGING_SIGN", 8);
        defaults.put("CRIMSON_WALL_SIGN", 8);
        defaults.put("DARK_OAK_HANGING_SIGN", 8);
        defaults.put("DARK_OAK_SIGN", 8);
        defaults.put("DARK_OAK_WALL_HANGING_SIGN", 8);
        defaults.put("DARK_OAK_WALL_SIGN", 8);
        defaults.put("JUNGLE_HANGING_SIGN", 8);
        defaults.put("JUNGLE_SIGN", 8);
        defaults.put("JUNGLE_WALL_HANGING_SIGN", 8);
        defaults.put("JUNGLE_WALL_SIGN", 8);
        defaults.put("MANGROVE_HANGING_SIGN", 8);
        defaults.put("MANGROVE_SIGN", 8);
        defaults.put("MANGROVE_WALL_HANGING_SIGN", 8);
        defaults.put("MANGROVE_WALL_SIGN", 8);
        defaults.put("OAK_HANGING_SIGN", 8);
        defaults.put("OAK_SIGN", 8);
        defaults.put("OAK_WALL_HANGING_SIGN", 8);
        defaults.put("OAK_WALL_SIGN", 8);
        defaults.put("SPRUCE_HANGING_SIGN", 8);
        defaults.put("SPRUCE_SIGN", 8);
        defaults.put("SPRUCE_WALL_HANGING_SIGN", 8);
        defaults.put("SPRUCE_WALL_SIGN", 8);
        defaults.put("WARPED_HANGING_SIGN", 8);
        defaults.put("WARPED_SIGN", 8);
        defaults.put("WARPED_WALL_HANGING_SIGN", 8);
        defaults.put("WARPED_WALL_SIGN", 8);
        // Banners
        defaults.put("BLACK_BANNER", 12);
        defaults.put("BLACK_WALL_BANNER", 12);
        defaults.put("BLUE_BANNER", 12);
        defaults.put("BLUE_WALL_BANNER", 12);
        defaults.put("BROWN_BANNER", 12);
        defaults.put("BROWN_WALL_BANNER", 12);
        defaults.put("CYAN_BANNER", 12);
        defaults.put("CYAN_WALL_BANNER", 12);
        defaults.put("GRAY_BANNER", 12);
        defaults.put("GRAY_WALL_BANNER", 12);
        defaults.put("GREEN_BANNER", 12);
        defaults.put("GREEN_WALL_BANNER", 12);
        defaults.put("LIGHT_BLUE_BANNER", 12);
        defaults.put("LIGHT_BLUE_WALL_BANNER", 12);
        defaults.put("LIGHT_GRAY_BANNER", 12);
        defaults.put("LIGHT_GRAY_WALL_BANNER", 12);
        defaults.put("LIME_BANNER", 12);
        defaults.put("LIME_WALL_BANNER", 12);
        defaults.put("MAGENTA_BANNER", 12);
        defaults.put("MAGENTA_WALL_BANNER", 12);
        defaults.put("ORANGE_BANNER", 12);
        defaults.put("ORANGE_WALL_BANNER", 12);
        defaults.put("PINK_BANNER", 12);
        defaults.put("PINK_WALL_BANNER", 12);
        defaults.put("PURPLE_BANNER", 12);
        defaults.put("PURPLE_WALL_BANNER", 12);
        defaults.put("RED_BANNER", 12);
        defaults.put("RED_WALL_BANNER", 12);
        defaults.put("YELLOW_BANNER", 12);
        defaults.put("YELLOW_WALL_BANNER", 12);

        ConfigSection section = AnarchyExploitFixes.getConfiguration().getConfigSection(configPath() + ".max-blocks-per-chunk", defaults,
                "Attempt to prevent ChunkBan / Client FPS Lag");
        for (String configuredMaterial : section.getKeys(false)) {
            try {
                Material blockMaterial = Material.valueOf(configuredMaterial);
                Integer maxAmountPerChunk = Integer.valueOf(section.getString(configuredMaterial));
                this.blockLimits.put(blockMaterial, maxAmountPerChunk);
            } catch (NumberFormatException e) {
                notRecognized(Integer.class, configuredMaterial);
            } catch (IllegalArgumentException e) {
                notRecognized(Material.class, configuredMaterial);
            }
        }
    }

    @Override
    public String configPath() {
        return "chunk-limits.block-limit";
    }

    @Override
    public void enable() {
        AnarchyExploitFixes plugin = AnarchyExploitFixes.getInstance();
        plugin.getServer().getPluginManager().registerEvents(this, plugin);
    }

    @Override
    public boolean shouldEnable() {
        return AnarchyExploitFixes.getConfiguration().getBoolean(configPath() + ".enable", false) && !blockLimits.isEmpty();
    }

    @Override
    public void disable() {
        HandlerList.unregisterAll(this);
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    private void onBlockPlace(BlockPlaceEvent event) {
        final Material placedType = event.getBlock().getType();
        if (
                blockLimits.containsKey(placedType)
                && exceedsPerChunkLimit(placedType, blockLimits.get(placedType), event.getBlock().getChunk())
        ) {
            event.setCancelled(true);
        }
    }

    private boolean exceedsPerChunkLimit(Material material, int limit, Chunk chunk) {
        final int minY = chunk.getWorld().getMinHeight();
        final int maxY = chunk.getWorld().getMaxHeight();
        int count = 0;
        for (int x = 0; x < 16; x++) {
            for (int z = 0; z < 16; z++) {
                for (int y = minY; y < maxY; y++) {
                    if (chunk.getBlock(x, y, z).getType() == material) {
                        count++;
                        if (count > limit) return true;
                    }
                }
            }
        }
        return false;
    }
}
