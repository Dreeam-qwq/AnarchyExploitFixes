package me.moomoo.anarchyexploitfixes.modules.packets;

import com.github.retrooper.packetevents.PacketEvents;
import com.github.retrooper.packetevents.event.PacketListenerPriority;
import com.github.retrooper.packetevents.event.PacketSendEvent;
import com.github.retrooper.packetevents.protocol.packettype.PacketType;
import com.github.retrooper.packetevents.util.Vector3d;
import com.github.retrooper.packetevents.wrapper.play.server.WrapperPlayServerSpawnEntity;
import me.moomoo.anarchyexploitfixes.AnarchyExploitFixes;
import me.moomoo.anarchyexploitfixes.config.Config;

import java.util.Optional;
import java.util.Random;

public class RandarObfuscator extends AEFPacketModule {

    private final Random[] randoms;
    private final Random selector;
    private final double positionBound, velocityBound;
    private final int randoms_len;

    public RandarObfuscator() {
        super(PacketListenerPriority.HIGHEST);
        shouldEnable();
        Config config = AnarchyExploitFixes.getConfiguration();
        config.addComment(configPath() + ".enable", """
                Should only affect server version 1.8 - 1.12.2.
                Patches an exploit that allows players to track other players using location data
                of specific entities like dropped items or lit TNT.
                This is possible due to the server handling random events in a not so random way.
                An in-depth explanation can be found here: https://github.com/spawnmason/randar-explanation
                If you'd rather watch a video about it, FitMC covered it here: https://www.youtube.com/watch?v=maMpMOnIJDE
                This solution is a tad bit hacky, its recommended to patch it inside paper instead if you know how to do it.
                You can use leijurv's patch for that purpose:
                https://github.com/spawnmason/PaperWithRandarPatched/commit/a5cd8a5a4b1e031201bbc60c0580bbabbc0ee5b7"""
        );
        this.positionBound = Math.abs(config.getDouble(configPath() + ".max-new-random-location-offset-blocks", 0.5));
        this.velocityBound = Math.abs(config.getDouble(configPath() + ".max-new-random-velocity-offset", 0.1));
        this.randoms_len = config.getInt(configPath() + ".how-many-randoms-should-we-use", 6,
                "How many Random objects to use for generating new entity spawn locations.\n" +
                        "One should technically be enough but theres no harm in making extra sure.");
        this.selector = new Random();
        this.randoms = new Random[randoms_len];
        for (int i = 0; i < randoms_len; i++) {
            randoms[i] = new Random();
        }
    }

    @Override
    public String configPath() {
        return "patches.prevent-randar-coordinate-exploit";
    }

    @Override
    public void enable() {
        PacketEvents.getAPI().getEventManager().registerListener(this);
    }

    @Override
    public void disable() {
        PacketEvents.getAPI().getEventManager().unregisterListener(this);
    }

    @Override
    public boolean shouldEnable() {
        return AnarchyExploitFixes.getConfiguration().getBoolean(configPath() + ".enable", false);
    }

    @Override
    public void onPacketSend(PacketSendEvent event) {
        if (event.getPacketType() != PacketType.Play.Server.SPAWN_ENTITY) return;
        WrapperPlayServerSpawnEntity packet = new WrapperPlayServerSpawnEntity(event);
        Vector3d originalPosition = packet.getPosition();

        packet.setPosition(new Vector3d(
                ((int) originalPosition.x) + getNewOffset(positionBound),
                originalPosition.y,
                ((int) originalPosition.z) + getNewOffset(positionBound)
        ));

        if (packet.getVelocity().isPresent()) {
            Vector3d originalVelocity = packet.getVelocity().get();
            packet.setVelocity(Optional.of(new Vector3d(
                    ((int) originalVelocity.x) + getNewOffset(velocityBound),
                    originalVelocity.y,
                    ((int) originalVelocity.z) + getNewOffset(velocityBound)
            )));
        }

        event.markForReEncode(true);
    }

    private double getNewOffset(double bound) {
        return (randoms_len <= 1 ? selector : randoms[selector.nextInt(randoms_len)]).nextDouble(-bound, bound);
    }
}
