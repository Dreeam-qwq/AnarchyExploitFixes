package me.xginko.aef.commands.aef;

import me.xginko.aef.AnarchyExploitFixes;
import me.xginko.aef.commands.AEFCommand;
import me.xginko.aef.commands.SubCommand;
import me.xginko.aef.commands.aef.subcommands.*;
import org.bukkit.ChatColor;
import org.bukkit.command.Command;
import org.bukkit.command.CommandException;
import org.bukkit.command.CommandSender;
import org.jetbrains.annotations.NotNull;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class AEFCmd extends Command implements AEFCommand {

    private final List<SubCommand> subCommands;
    private final List<String> tabCompletes;
    private final List<String> overview = Stream.of(
            "",
            "                 &b&lAnarchyExploitFixes Commands",
            "",
            "  &b/aef version &8- &fShow the plugin version.",
            "  &b/aef reload &8- &fReload the plugin.",
            "  &b/aef disable &8- &fDisable the plugin.",
            "  &b/aef lag <millis> &8- &fLag the server for testing.",
            "  &b/aef datavalue &8- &fShow the MaterialData value of an item.",
            "  &b/aef geared &8- &fCount how many players are wearing gear.",
            "  &b/aef elytra &8- &fCount how many players are flying elytra.",
            ""
    ).map(line -> ChatColor.translateAlternateColorCodes('&', line)).collect(Collectors.toList());

    public AEFCmd() {
        super(
                "aef",
                "AnarchyExploitFixes admin commands",
                "/aef <reload, version, disable, elytra, geared, lag>",
                Collections.emptyList()
        );
        this.subCommands = Arrays.asList(
                new ReloadSubCmd(),
                new VersionSubCmd(),
                new DisableSubCmd(),
                new LagSubCmd(),
                new ElytraSubCmd(),
                new GearedSubCmd()
        );
        this.tabCompletes = subCommands.stream().map(SubCommand::label).sorted().collect(Collectors.toList());
    }

    @Override
    public boolean shouldEnable() {
        return true;
    }

    @Override
    public void enable() {
        AnarchyExploitFixes plugin = AnarchyExploitFixes.getInstance();
        plugin.getServer().getCommandMap().register(plugin.getDescription().getName().toLowerCase(), this);
    }

    @Override
    public @NotNull List<String> tabComplete(@NotNull CommandSender sender, @NotNull String alias, @NotNull String[] args)
            throws CommandException, IllegalArgumentException
    {
        if (args.length == 1) {
            return tabCompletes;
        }

        if (args.length >= 2) {
            for (SubCommand subCommand : subCommands) {
                if (args[0].equalsIgnoreCase(subCommand.label())) {
                    return subCommand.tabComplete(sender, alias, args);
                }
            }
        }

        return Collections.emptyList();
    }

    @Override
    public boolean execute(@NotNull CommandSender sender, @NotNull String commandLabel, @NotNull String[] args) {
        if (args.length >= 1) {
            for (SubCommand subCommand : subCommands) {
                if (args[0].equalsIgnoreCase(subCommand.label())) {
                    return subCommand.execute(sender, commandLabel, args);
                }
            }
        }

        overview.forEach(sender::sendMessage);
        return true;
    }
}
