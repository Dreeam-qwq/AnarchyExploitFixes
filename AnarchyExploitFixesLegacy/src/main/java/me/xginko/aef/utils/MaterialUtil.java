package me.xginko.aef.utils;

import com.cryptomorin.xseries.XMaterial;
import com.cryptomorin.xseries.XTag;
import io.papermc.lib.PaperLib;
import org.bukkit.Material;
import org.bukkit.SkullType;
import org.bukkit.block.BlockState;
import org.bukkit.block.Skull;
import org.bukkit.inventory.InventoryHolder;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.BlockStateMeta;
import org.bukkit.inventory.meta.SkullMeta;

import java.util.Arrays;
import java.util.EnumSet;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class MaterialUtil {

    // Blocks that the player gets lowered into slightly when walking on them
    public static final Set<Material> SINK_IN_BLOCKS = Stream.of(
            XMaterial.SOUL_SAND,
            XMaterial.FARMLAND,
            XMaterial.MUD
            ).filter(XMaterial::isSupported)
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

    public static final Set<Material> PLAYER_HEADS = Stream.of(
            XMaterial.PLAYER_HEAD,
            XMaterial.PLAYER_WALL_HEAD
            ).filter(XMaterial::isSupported)
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

    public static boolean isPlayerHead(BlockState state) {
        if (!PLAYER_HEADS.contains(state.getType()))
            return false;
        if (PaperLib.getMinecraftVersion() > 12)
            return true;
        Skull skull = (Skull) state;
        return skull.getSkullType() == SkullType.PLAYER || skull.hasOwner();
    }

    public static boolean isPlayerHead(ItemStack itemStack) {
        if (!PLAYER_HEADS.contains(itemStack.getType()))
            return false;
        if (PaperLib.getMinecraftVersion() > 12)
            return true;
        return ((SkullMeta) itemStack.getItemMeta()).hasOwner();
    }

    public static final Set<Material> REDSTONE = Stream.of(
            XMaterial.REDSTONE,
            XMaterial.REDSTONE_WIRE
            ).filter(XMaterial::isSupported)
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

    public static final Set<Material> SOLID_INDESTRUCTIBLES = Stream.of(
            XMaterial.BEDROCK,
            XMaterial.END_PORTAL_FRAME,
            XMaterial.REINFORCED_DEEPSLATE,
            XMaterial.STRUCTURE_BLOCK,
            XMaterial.STRUCTURE_VOID,
            XMaterial.BARRIER,
            XMaterial.COMMAND_BLOCK
            ).filter(XMaterial::isSupported)
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

    public static final Set<Material> TEXT_BOOKS = Arrays.stream(XMaterial.values())
            .filter(xMaterial -> {
                if (!xMaterial.isSupported()) return false;
                return xMaterial.name().toUpperCase().contains("BOOK") && xMaterial != XMaterial.ENCHANTED_BOOK;
            })
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

    public static final Set<Material> INDESTRUCTIBLES = Stream.concat(SOLID_INDESTRUCTIBLES.stream(), Stream.of(
            XMaterial.END_PORTAL.parseMaterial()
            )).filter(Objects::nonNull)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

    public static final Set<Material> SHULKER_BOXES = Arrays.stream(XMaterial.values())
            .filter(xMaterial -> xMaterial.name().toUpperCase().endsWith("SHULKER_BOX") && xMaterial.isSupported())
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

    public static final Set<Material> SIGNS = Arrays.stream(XMaterial.values())
            .filter(xMaterial -> xMaterial.name().toUpperCase().endsWith("_SIGN") && xMaterial.isSupported())
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

    public static final Set<Material> PISTONS = Arrays.stream(XMaterial.values())
            .filter(xMaterial -> xMaterial.name().toUpperCase().contains("PISTON") && xMaterial.isSupported())
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

    public static final Set<Material> TRAPDOORS = Arrays.stream(XMaterial.values())
            .filter(xMaterial -> xMaterial.name().toUpperCase().endsWith("_TRAPDOOR") && xMaterial.isSupported())
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

    public static final Set<Material> ANVILS = XTag.ANVIL.getValues().stream()
            .filter(XMaterial::isSupported)
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

    public static final Set<Material> BLOCK_DISPENSE_BUCKETS = Stream.of(
            XMaterial.WATER_BUCKET,
            XMaterial.LAVA_BUCKET,
            XMaterial.COD_BUCKET,
            XMaterial.SALMON_BUCKET,
            XMaterial.PUFFERFISH_BUCKET,
            XMaterial.TROPICAL_FISH_BUCKET,
            XMaterial.AXOLOTL_BUCKET,
            XMaterial.TADPOLE_BUCKET,
            XMaterial.POWDER_SNOW_BUCKET
            ).filter(XMaterial::isSupported)
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

    public static final Set<Material> SPAWN_EGGS = Arrays.stream(XMaterial.values())
            .filter(xMaterial -> xMaterial.name().toUpperCase().endsWith("_SPAWN_EGG") && xMaterial.isSupported())
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

    public static final Set<Material> INVENTORY_HOLDER_BLOCKS = Arrays.stream(Material.values())
            .map(ItemStack::new)
            .filter(itemStack -> itemStack.getItemMeta() instanceof BlockStateMeta)
            .map(itemStack -> ((BlockStateMeta) itemStack.getItemMeta()).getBlockState())
            .filter(blockState -> blockState instanceof InventoryHolder)
            .map(BlockState::getType)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

    private static final Material ELYTRA = XMaterial.ELYTRA.parseMaterial();
    public static boolean isElytra(ItemStack item) {
        if (item == null) return false;
        return item.getType() == ELYTRA;
    }
}