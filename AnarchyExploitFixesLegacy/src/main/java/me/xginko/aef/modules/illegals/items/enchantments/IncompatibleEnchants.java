package me.xginko.aef.modules.illegals.items.enchantments;

import com.cryptomorin.xseries.XEnchantment;
import me.xginko.aef.enums.AEFPermission;
import me.xginko.aef.enums.IllegalHandling;
import me.xginko.aef.enums.ItemLegality;
import me.xginko.aef.modules.illegals.items.IllegalItemModule;
import me.xginko.aef.utils.ItemUtil;
import org.bukkit.Material;
import org.bukkit.enchantments.Enchantment;
import org.bukkit.inventory.ItemStack;

import java.util.Collections;
import java.util.EnumSet;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;

public class IncompatibleEnchants extends IllegalItemModule {

    private static final Enchantment BINDING_CURSE = XEnchantment.BINDING_CURSE.getEnchant();
    private static final Enchantment VANISHING_CURSE = XEnchantment.VANISHING_CURSE.getEnchant();
    private static final Enchantment MULTISHOT = XEnchantment.MULTISHOT.getEnchant();
    private static final Enchantment PIERCING = XEnchantment.PIERCING.getEnchant();
    private static final Enchantment RIPTIDE = XEnchantment.RIPTIDE.getEnchant();
    private static final Enchantment LOYALTY = XEnchantment.LOYALTY.getEnchant();
    private static final Enchantment CHANNELING = XEnchantment.CHANNELING.getEnchant();
    private static final Enchantment MENDING = XEnchantment.MENDING.getEnchant();
    private static final Enchantment INFINITY = XEnchantment.INFINITY.getEnchant();
    private static final Enchantment SILK_TOUCH = XEnchantment.SILK_TOUCH.getEnchant();
    private static final Enchantment FORTUNE = XEnchantment.FORTUNE.getEnchant();
    private static final Enchantment DEPTH_STRIDER = XEnchantment.DEPTH_STRIDER.getEnchant();
    private static final Enchantment FROST_WALKER = XEnchantment.FROST_WALKER.getEnchant();
    private static final Enchantment SHARPNESS = XEnchantment.SHARPNESS.getEnchant();
    private static final Enchantment BANE_OF_ARTHROPODS = XEnchantment.BANE_OF_ARTHROPODS.getEnchant();
    private static final Enchantment SMITE = XEnchantment.SMITE.getEnchant();
    private static final Enchantment PROTECTION = XEnchantment.PROTECTION.getEnchant();
    private static final Enchantment BLAST_PROTECTION = XEnchantment.BLAST_PROTECTION.getEnchant();
    private static final Enchantment FIRE_PROTECTION = XEnchantment.FIRE_PROTECTION.getEnchant();
    private static final Enchantment PROJECTILE_PROTECTION = XEnchantment.PROJECTILE_PROTECTION.getEnchant();

    private static final Enchantment[] PROTECT_ENCHANTS = {
            PROTECTION, BLAST_PROTECTION, FIRE_PROTECTION, PROJECTILE_PROTECTION
    };

    private static final Enchantment[] DAMAGE_ENCHANTS = {
            SHARPNESS, SMITE, BANE_OF_ARTHROPODS
    };

    private final Set<Material> whitelistedTypes;
    private final boolean useWhitelist, blacklistMode, checkStored;

    public IncompatibleEnchants() {
        super("illegals.enchantments.incompatible-enchants", AEFPermission.BYPASS_ILLEGAL_ENCHANT_INCOMPATIBLE);
        config.addComment(configPath + ".enable",
                "Bypass permission: " + bypassPermission.string() + "\n" +
                "Reverts or prevents usage of ItemStacks with Enchantments that\n" +
                "cannot coexist in vanilla survival minecraft.\n" +
                "Examples: A bow with mending and infinity or armor with every\n" +
                "protection enchantment.");
        this.checkStored = config.getBoolean(configPath + ".check-stored-items", false);
        this.useWhitelist = config.getBoolean(configPath + ".item-whitelist-enabled", true);
        this.blacklistMode = config.getBoolean(configPath + ".use-as-blacklist-instead", false);
        this.whitelistedTypes = config.getList(configPath + ".whitelisted-items", Collections.singletonList("BOW"))
                .stream()
                .map(configuredType -> {
                    try {
                        return Material.valueOf(configuredType);
                    } catch (IllegalArgumentException e) {
                        notRecognized(Material.class, configuredType);
                        return null;
                    }
                })
                .filter(Objects::nonNull)
                .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));
    }

    @Override
    public boolean shouldEnable() {
        return config.getBoolean(configPath + ".enable", false);
    }

    @Override
    public ItemLegality legalityOf(ItemStack itemStack) {
        if (itemStack == null || itemStack.getType() == Material.AIR) {
            return ItemLegality.LEGAL;
        }

        if (!useWhitelist || blacklistMode == whitelistedTypes.contains(itemStack.getType())) {
            final Set<Enchantment> enchantments = itemStack.getEnchantments().keySet();

            if (!enchantments.isEmpty()) {
                if (enchantments.contains(BINDING_CURSE) && enchantments.contains(VANISHING_CURSE))
                    return ItemLegality.ILLEGAL;
                if (enchantments.contains(INFINITY) && enchantments.contains(MENDING))
                    return ItemLegality.ILLEGAL;
                if (enchantments.contains(SILK_TOUCH) && enchantments.contains(FORTUNE))
                    return ItemLegality.ILLEGAL;
                if (enchantments.contains(DEPTH_STRIDER) && enchantments.contains(FROST_WALKER))
                    return ItemLegality.ILLEGAL;
                if (enchantments.contains(MULTISHOT) && enchantments.contains(PIERCING))
                    return ItemLegality.ILLEGAL;
                if (enchantments.contains(RIPTIDE) && (enchantments.contains(LOYALTY) || enchantments.contains(CHANNELING)))
                    return ItemLegality.ILLEGAL;

                int dmgEnchCount = 0;
                for (Enchantment damageEnchant : DAMAGE_ENCHANTS) {
                    if (enchantments.contains(damageEnchant)) {
                        dmgEnchCount++;
                        if (dmgEnchCount > 1) {
                            return ItemLegality.ILLEGAL;
                        }
                    }
                }

                int protEnchCount = 0;
                for (Enchantment protectEnchant : PROTECT_ENCHANTS) {
                    if (enchantments.contains(protectEnchant)) {
                        protEnchCount++;
                        if (protEnchCount > 1) {
                            return ItemLegality.ILLEGAL;
                        }
                    }
                }
            }
        }

        if (checkStored) {
            return legalityOf(ItemUtil.getStoredItems(itemStack));
        }

        return ItemLegality.LEGAL;
    }

    @Override
    public void handleItem(ItemStack itemStack, ItemLegality legality) {
        if (legality == ItemLegality.LEGAL) return;
        if (handling == IllegalHandling.PREVENT_USE_ONLY) return; // We are cancelling the action in the super class

        if (legality == ItemLegality.CONTAINS_ILLEGAL) {
            itemStack.setAmount(0);
            return;
        }

        final Set<Enchantment> enchantments = itemStack.getEnchantments().keySet();

        if (enchantments.contains(BINDING_CURSE) && enchantments.contains(VANISHING_CURSE))
            itemStack.removeEnchantment(BINDING_CURSE);
        if (enchantments.contains(MULTISHOT) && enchantments.contains(PIERCING))
            itemStack.removeEnchantment(MULTISHOT);
        if (enchantments.contains(RIPTIDE) && (enchantments.contains(LOYALTY) || enchantments.contains(CHANNELING)))
            itemStack.removeEnchantment(RIPTIDE);
        if (enchantments.contains(INFINITY) && enchantments.contains(MENDING))
            itemStack.removeEnchantment(INFINITY);
        if (enchantments.contains(SILK_TOUCH) && enchantments.contains(FORTUNE))
            itemStack.removeEnchantment(FORTUNE);
        if (enchantments.contains(DEPTH_STRIDER) && enchantments.contains(FROST_WALKER))
            itemStack.removeEnchantment(FROST_WALKER);

        if (enchantments.contains(SHARPNESS)) { // Prefer keeping Sharpness enchantment if present
            for (Enchantment dmgEnchant : DAMAGE_ENCHANTS) {
                if (dmgEnchant != SHARPNESS) {
                    itemStack.removeEnchantment(dmgEnchant);
                }
            }
        } else if (enchantments.contains(BANE_OF_ARTHROPODS) && enchantments.contains(SMITE)) {
            itemStack.removeEnchantment(BANE_OF_ARTHROPODS);
        }

        if (enchantments.contains(PROTECTION)) { // Prefer keeping Protection enchantment if present
            for (Enchantment protEnchant : PROTECT_ENCHANTS) {
                if (protEnchant != PROTECTION) {
                    itemStack.removeEnchantment(protEnchant);
                }
            }
        } else if (enchantments.contains(BLAST_PROTECTION)) { // If protection is present, prefer blast protection
            for (Enchantment protEnchant : PROTECT_ENCHANTS) {
                if (protEnchant != BLAST_PROTECTION) {
                    itemStack.removeEnchantment(protEnchant);
                }
            }
        } else if (enchantments.contains(PROJECTILE_PROTECTION) && enchantments.contains(FIRE_PROTECTION)) {
            itemStack.removeEnchantment(FIRE_PROTECTION); // If protection and blast protection is not present, prefer projectile protection
        }
    }
}
