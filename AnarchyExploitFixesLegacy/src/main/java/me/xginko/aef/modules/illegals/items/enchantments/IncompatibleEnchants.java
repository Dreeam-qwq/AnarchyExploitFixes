package me.xginko.aef.modules.illegals.items.enchantments;

import com.cryptomorin.xseries.XEnchantment;
import me.xginko.aef.enums.AEFPermission;
import me.xginko.aef.enums.IllegalHandling;
import me.xginko.aef.enums.ItemLegality;
import me.xginko.aef.modules.illegals.items.IllegalItemModule;
import me.xginko.aef.utils.ItemUtil;
import org.bukkit.Material;
import org.bukkit.enchantments.Enchantment;
import org.bukkit.inventory.ItemStack;

import java.util.Collections;
import java.util.EnumSet;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;

public class IncompatibleEnchants extends IllegalItemModule {

    private static final Enchantment BINDING_CURSE = XEnchantment.BINDING_CURSE.getEnchant();
    private static final Enchantment VANISHING_CURSE = XEnchantment.VANISHING_CURSE.getEnchant();
    private static final Enchantment CROSSBOW_MULTISHOT = XEnchantment.MULTISHOT.getEnchant();
    private static final Enchantment CROSSBOW_PIERCING = XEnchantment.PIERCING.getEnchant();
    private static final Enchantment TRIDENT_RIPTIDE = XEnchantment.RIPTIDE.getEnchant();
    private static final Enchantment TRIDENT_LOYALTY = XEnchantment.LOYALTY.getEnchant();
    private static final Enchantment TRIDENT_CHANNELING = XEnchantment.CHANNELING.getEnchant();
    private static final Enchantment MENDING = XEnchantment.MENDING.getEnchant();
    private static final Enchantment BOW_ARROW_INFINITE = XEnchantment.ARROW_INFINITE.getEnchant();
    private static final Enchantment TOOLS_SILK_TOUCH = XEnchantment.SILK_TOUCH.getEnchant();
    private static final Enchantment TOOLS_LOOT_BONUS_BLOCKS = XEnchantment.LOOT_BONUS_BLOCKS.getEnchant();
    private static final Enchantment BOOTS_DEPTH_STRIDER = XEnchantment.DEPTH_STRIDER.getEnchant();
    private static final Enchantment BOOTS_FROST_WALKER = XEnchantment.FROST_WALKER.getEnchant();
    private static final Enchantment SWORD_DAMAGE_ALL = XEnchantment.DAMAGE_ALL.getEnchant();
    private static final Enchantment SWORD_DAMAGE_ARTHROPODS = XEnchantment.DAMAGE_ARTHROPODS.getEnchant();
    private static final Enchantment SWORD_DAMAGE_UNDEAD = XEnchantment.DAMAGE_UNDEAD.getEnchant();
    private static final Enchantment ARMOR_PROTECTION_ENVIRONMENTAL = XEnchantment.PROTECTION_ENVIRONMENTAL.getEnchant();
    private static final Enchantment ARMOR_PROTECTION_EXPLOSIONS = XEnchantment.PROTECTION_EXPLOSIONS.getEnchant();
    private static final Enchantment ARMOR_PROTECTION_FIRE = XEnchantment.PROTECTION_FIRE.getEnchant();
    private static final Enchantment ARMOR_PROTECTION_PROJECTILE = XEnchantment.PROTECTION_PROJECTILE.getEnchant();

    private static final Enchantment[] PROTECT_ENCHANTS = {
            ARMOR_PROTECTION_ENVIRONMENTAL, ARMOR_PROTECTION_EXPLOSIONS, ARMOR_PROTECTION_FIRE, ARMOR_PROTECTION_PROJECTILE
    };

    private static final Enchantment[] DAMAGE_ENCHANTS = {
            SWORD_DAMAGE_ALL, SWORD_DAMAGE_UNDEAD, SWORD_DAMAGE_ARTHROPODS
    };

    private final Set<Material> whitelistedTypes;
    private final boolean useWhitelist, blacklistMode, checkStored;

    public IncompatibleEnchants() {
        super("illegals.enchantments.incompatible-enchants", AEFPermission.BYPASS_ILLEGAL_ENCHANT_INCOMPATIBLE);
        config.addComment(configPath + ".enable",
                "Bypass permission: " + bypassPermission.string() + "\n" +
                "Reverts or prevents usage of ItemStacks with Enchantments that\n" +
                "cannot coexist in vanilla survival minecraft.\n" +
                "Examples: A bow with mending and infinity or armor with every\n" +
                "protection enchantment.");
        this.checkStored = config.getBoolean(configPath + ".check-stored-items", false);
        this.useWhitelist = config.getBoolean(configPath + ".item-whitelist-enabled", true);
        this.blacklistMode = config.getBoolean(configPath + ".use-as-blacklist-instead", false);
        this.whitelistedTypes = config.getList(configPath + ".whitelisted-items", Collections.singletonList("BOW"))
                .stream()
                .map(configuredType -> {
                    try {
                        return Material.valueOf(configuredType);
                    } catch (IllegalArgumentException e) {
                        notRecognized(Material.class, configuredType);
                        return null;
                    }
                })
                .filter(Objects::nonNull)
                .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));
    }

    @Override
    public boolean shouldEnable() {
        return config.getBoolean(configPath + ".enable", false);
    }

    @Override
    public ItemLegality legalityOf(ItemStack itemStack) {
        if (itemStack == null || itemStack.getType() == Material.AIR) {
            return ItemLegality.LEGAL;
        }

        if (!useWhitelist || blacklistMode == whitelistedTypes.contains(itemStack.getType())) {
            final Set<Enchantment> enchantments = itemStack.getEnchantments().keySet();

            if (!enchantments.isEmpty()) {
                if (enchantments.contains(BINDING_CURSE) && enchantments.contains(VANISHING_CURSE))
                    return ItemLegality.ILLEGAL;
                if (enchantments.contains(BOW_ARROW_INFINITE) && enchantments.contains(MENDING))
                    return ItemLegality.ILLEGAL;
                if (enchantments.contains(TOOLS_SILK_TOUCH) && enchantments.contains(TOOLS_LOOT_BONUS_BLOCKS))
                    return ItemLegality.ILLEGAL;
                if (enchantments.contains(BOOTS_DEPTH_STRIDER) && enchantments.contains(BOOTS_FROST_WALKER))
                    return ItemLegality.ILLEGAL;
                if (enchantments.contains(CROSSBOW_MULTISHOT) && enchantments.contains(CROSSBOW_PIERCING))
                    return ItemLegality.ILLEGAL;
                if (enchantments.contains(TRIDENT_RIPTIDE) && (enchantments.contains(TRIDENT_LOYALTY) || enchantments.contains(TRIDENT_CHANNELING)))
                    return ItemLegality.ILLEGAL;

                int dmgEnchCount = 0;
                for (Enchantment damageEnchant : DAMAGE_ENCHANTS) {
                    if (enchantments.contains(damageEnchant)) {
                        dmgEnchCount++;
                        if (dmgEnchCount > 1) {
                            return ItemLegality.ILLEGAL;
                        }
                    }
                }

                int protEnchCount = 0;
                for (Enchantment protectEnchant : PROTECT_ENCHANTS) {
                    if (enchantments.contains(protectEnchant)) {
                        protEnchCount++;
                        if (protEnchCount > 1) {
                            return ItemLegality.ILLEGAL;
                        }
                    }
                }
            }
        }

        if (checkStored) {
            return legalityOf(ItemUtil.getStoredItems(itemStack));
        }

        return ItemLegality.LEGAL;
    }

    @Override
    public void handleItem(ItemStack itemStack, ItemLegality legality) {
        if (legality == ItemLegality.LEGAL) return;
        if (handling == IllegalHandling.PREVENT_USE_ONLY) return; // We are cancelling the action in the super class

        if (legality == ItemLegality.CONTAINS_ILLEGAL) {
            itemStack.setAmount(0);
            return;
        }

        final Set<Enchantment> enchantments = itemStack.getEnchantments().keySet();

        if (enchantments.contains(BINDING_CURSE) && enchantments.contains(VANISHING_CURSE))
            itemStack.removeEnchantment(BINDING_CURSE);
        if (enchantments.contains(CROSSBOW_MULTISHOT) && enchantments.contains(CROSSBOW_PIERCING))
            itemStack.removeEnchantment(CROSSBOW_MULTISHOT);
        if (enchantments.contains(TRIDENT_RIPTIDE) && (enchantments.contains(TRIDENT_LOYALTY) || enchantments.contains(TRIDENT_CHANNELING)))
            itemStack.removeEnchantment(TRIDENT_RIPTIDE);
        if (enchantments.contains(BOW_ARROW_INFINITE) && enchantments.contains(MENDING))
            itemStack.removeEnchantment(BOW_ARROW_INFINITE);
        if (enchantments.contains(TOOLS_SILK_TOUCH) && enchantments.contains(TOOLS_LOOT_BONUS_BLOCKS))
            itemStack.removeEnchantment(TOOLS_LOOT_BONUS_BLOCKS);
        if (enchantments.contains(BOOTS_DEPTH_STRIDER) && enchantments.contains(BOOTS_FROST_WALKER))
            itemStack.removeEnchantment(BOOTS_FROST_WALKER);

        if (enchantments.contains(SWORD_DAMAGE_ALL)) { // Prefer keeping Sharpness enchantment if present
            for (Enchantment dmgEnchant : DAMAGE_ENCHANTS) {
                if (dmgEnchant != SWORD_DAMAGE_ALL) {
                    itemStack.removeEnchantment(dmgEnchant);
                }
            }
        } else if (enchantments.contains(SWORD_DAMAGE_ARTHROPODS) && enchantments.contains(SWORD_DAMAGE_UNDEAD)) {
            itemStack.removeEnchantment(SWORD_DAMAGE_ARTHROPODS);
        }

        if (enchantments.contains(ARMOR_PROTECTION_ENVIRONMENTAL)) { // Prefer keeping Protection enchantment if present
            for (Enchantment protEnchant : PROTECT_ENCHANTS) {
                if (protEnchant != ARMOR_PROTECTION_ENVIRONMENTAL) {
                    itemStack.removeEnchantment(protEnchant);
                }
            }
        } else if (enchantments.contains(ARMOR_PROTECTION_EXPLOSIONS)) { // If protection is present, prefer blast protection
            for (Enchantment protEnchant : PROTECT_ENCHANTS) {
                if (protEnchant != ARMOR_PROTECTION_EXPLOSIONS) {
                    itemStack.removeEnchantment(protEnchant);
                }
            }
        } else if (enchantments.contains(ARMOR_PROTECTION_PROJECTILE) && enchantments.contains(ARMOR_PROTECTION_FIRE)) {
            itemStack.removeEnchantment(ARMOR_PROTECTION_FIRE); // If protection and blast protection is not present, prefer projectile protection
        }
    }
}
