package me.xginko.aef.modules.elytra;

import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import me.xginko.aef.modules.AEFModule;
import me.xginko.aef.utils.ChunkUtil;
import me.xginko.aef.utils.LocationUtil;
import me.xginko.aef.utils.models.Disableable;
import me.xginko.aef.utils.models.ExpiringSet;
import org.bukkit.Chunk;
import org.bukkit.Location;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.HandlerList;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerMoveEvent;
import org.bukkit.event.world.ChunkLoadEvent;
import org.bukkit.util.NumberConversions;
import org.jetbrains.annotations.NotNull;

import java.time.Duration;
import java.util.Map;
import java.util.Set;
import java.util.UUID;

public class ElytraHelper extends AEFModule implements Disableable, Runnable, Listener {

    private static ElytraHelper instance;
    private final Cache<UUID, PlayerData> playerDataCache =
            Caffeine.newBuilder().expireAfterWrite(Duration.ofSeconds(3)).build();
    private NewChunksListener newChunkListener;

    public ElytraHelper() {
        super("elytra-helper");
        instance = this;
        newChunkListener = ChunkUtil.canGetInhabitedTime() ? null : new NewChunksListener();
    }

    public static ElytraHelper getInstance() {
        return instance;
    }

    @Override
    public void enable() {
        plugin.getServer().getScheduler().scheduleSyncRepeatingTask(plugin, this, 1L, 1L);
        plugin.getServer().getPluginManager().registerEvents(this, plugin);
        if (!ChunkUtil.canGetInhabitedTime())
            plugin.getServer().getPluginManager().registerEvents(newChunkListener, plugin);
    }

    @Override
    public void disable() {
        HandlerList.unregisterAll(this);
    }

    @Override
    public boolean shouldEnable() {
        return config.elytra_enable_at_spawn || config.elytra_enable_global || config.elytra_enable_netherceiling;
    }

    @Override
    public void run() {
        for (Map.Entry<UUID, PlayerData> entry : playerDataCache.asMap().entrySet()) {
            entry.getValue().update(config.elytra_calculate_3D);
        }
    }

    @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)
    private void onPlayerMove(PlayerMoveEvent event) {
        if (event.getPlayer().isGliding()) {
            playerDataCache.get(event.getPlayer().getUniqueId(),
                    k -> new PlayerData(event.getFrom(), event.getTo())).latest = event.getTo();
        }
    }

    public double getBlocksPerTick(PlayerMoveEvent event) {
        return playerDataCache.get(event.getPlayer().getUniqueId(),
                k -> new PlayerData(event.getFrom(), event.getTo())).getSpeedAvg();
    }

    public Location getSetbackLocation(PlayerMoveEvent event) {
        return playerDataCache.get(event.getPlayer().getUniqueId(),
                k -> new PlayerData(event.getFrom(), event.getTo())).previous;
    }

    public boolean isInNewChunks(Player player) {
        if (ChunkUtil.canGetInhabitedTime()) {
            return ChunkUtil.getInhabitedTime(player.getChunk()) <= 200L;
        } else {
            return newChunkListener.isInNewChunks(player.getUniqueId());
        }
    }

    private static class PlayerData {
        public @NotNull Location previous, latest;
        private double speedAvg;

        public PlayerData(@NotNull Location previous, @NotNull Location latest) {
            this.previous = previous;
            this.latest = latest;
        }

        public double getSpeedAvg() {
            return speedAvg;
        }

        public void update(boolean using3D) {
            speedAvg = using3D ? LocationUtil.getRelDistance3D(previous, latest) : LocationUtil.getRelDistance2D(previous, latest);
            speedAvg = Math.max(speedAvg - 0.02, 0); // Tolerance
            previous = latest.clone();
        }
    };

    private static class NewChunksListener implements Listener {
        /**
         * For 1.12 - 1.13 since Chunk#getInhabitedTime is only available starting at 1.14
         */
        private final Set<UUID> new_chunk_players;

        public NewChunksListener() {
            this.new_chunk_players = new ExpiringSet<>(Duration.ofMinutes(10));
        }

        @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)
        private void onChunkLoad(ChunkLoadEvent event) {
            for (Player player : event.getWorld().getPlayers()) {
                if (chunkDistanceSquared(event.getChunk(), player.getLocation()) < NumberConversions.square(player.getViewDistance())) {
                    if (event.isNewChunk()) {
                        this.new_chunk_players.add(player.getUniqueId());
                    } else {
                        this.new_chunk_players.remove(player.getUniqueId());
                    }
                }
            }
        }

        /**
         * Since the distance here is only used to see whether a chunk is loaded roughly within the player's view distance,
         * we can resort to comparing squared distances.
         * This saves cpu usage as we don't have to use {@link Math#sqrt(double)} to get the accurate distance in chunks.
         */
        private static double chunkDistanceSquared(Chunk chunk, Location location) {
            return  NumberConversions.square(chunk.getX() - (location.getBlockX() >> 4)) +
                    NumberConversions.square(chunk.getZ() - (location.getBlockZ() >> 4));
        }

        public boolean isInNewChunks(UUID player) {
            return new_chunk_players.contains(player);
        }
    };
}
