package me.moomoo.anarchyexploitfixes.modules.patches;

import io.papermc.lib.PaperLib;
import me.moomoo.anarchyexploitfixes.AnarchyExploitFixes;
import me.moomoo.anarchyexploitfixes.config.Config;
import me.moomoo.anarchyexploitfixes.modules.AEFModule;
import org.bukkit.Location;
import org.bukkit.entity.Entity;
import org.bukkit.event.Listener;
import org.bukkit.event.entity.EntitySpawnEvent;
import org.bukkit.event.entity.ItemSpawnEvent;

import java.util.Random;

public class RandarCoordExploit implements AEFModule, Listener {

    private final Random[] randoms;
    private final Random random;
    private final double offsetBound;
    private final int randsSize;
    private final Listener adaptiveListener;

    public RandarCoordExploit() {
        shouldEnable();
        Config config = AnarchyExploitFixes.getConfiguration();
        config.addComment(configPath() + ".enable", "According to https://github.com/spawnmason/randar-explanation,\n" +
                "server versions above 1.12.2 shouldn't be affected.");
        if (config.getBoolean(configPath() + ".enable-for-all-entity-spawns", false,
                "Whether all entity spawns should get their spawn location fixed.\n " +
                        "Will break all plugins checking CreatureSpawnEvent#getSpawnReason and create more overhead if set to true."))
            this.adaptiveListener = new Listener() {
                private void onEntitySpawn(EntitySpawnEvent event) {
                    fixSpawnLocation(event);
                }
            };
        else this.adaptiveListener = new Listener() {
            private void onItemSpawn(ItemSpawnEvent event) {
                fixSpawnLocation(event);
            }
        };
        this.offsetBound = Math.abs(config.getDouble(configPath() + ".max-new-random-location-offset-blocks", 1.5));
        this.randsSize = config.getInt(configPath() + ".how-many-randoms-should-we-use", 6,
                "How many Random objects to use for fixing entity spawn locations.\n" +
                        "One should already be enough but theres no harm in making extra sure.");
        this.random = new Random();
        this.randoms = new Random[randsSize];
        for (int i = 0; i < randsSize; i++) {
            randoms[i] = new Random();
        }
    }

    @Override
    public String configPath() {
        return "patches.prevent-randar-coordinate-exploit";
    }

    @Override
    public void enable() {
        AnarchyExploitFixes plugin = AnarchyExploitFixes.getInstance();
        plugin.getServer().getPluginManager().registerEvents(adaptiveListener, plugin);
    }

    @Override
    public boolean shouldEnable() {
        return AnarchyExploitFixes.getConfiguration().getBoolean(configPath() + ".enable", PaperLib.getMinecraftVersion() <= 12);
    }

    private void fixSpawnLocation(EntitySpawnEvent event) {
        event.setCancelled(true);

        Entity spawning = event.getEntity();

        Location fixedLocation = spawning.getLocation().clone();
        fixedLocation.setX(getNewRandomOffset(spawning.getLocation().getBlockX()));
        fixedLocation.setY(getNewRandomOffset(spawning.getLocation().getBlockY()));
        fixedLocation.setZ(getNewRandomOffset(spawning.getLocation().getBlockZ()));

        spawning.getWorld().spawnEntity(fixedLocation, spawning.getType());
    }

    private double getNewRandomOffset(double blockLoc) {
        return (randsSize <= 1 ? random : randoms[random.nextInt(randsSize)]).nextDouble(blockLoc, blockLoc + offsetBound);
    }
}
