package me.moomoo.anarchyexploitfixes.modules.packets;

import com.github.retrooper.packetevents.PacketEvents;
import com.github.retrooper.packetevents.event.PacketListenerPriority;
import com.github.retrooper.packetevents.event.PacketSendEvent;
import com.github.retrooper.packetevents.protocol.packettype.PacketType;
import com.github.retrooper.packetevents.util.Vector3d;
import com.github.retrooper.packetevents.wrapper.play.server.WrapperPlayServerSpawnEntity;
import io.papermc.lib.PaperLib;
import me.moomoo.anarchyexploitfixes.AnarchyExploitFixes;
import me.moomoo.anarchyexploitfixes.config.Config;

import java.util.Random;

public class RandarObfuscator extends AEFPacketModule {

    private final Random[] randoms;
    private final Random selector;
    private final double offsetBound;
    private final int randoms_len;

    public RandarObfuscator() {
        super(PacketListenerPriority.HIGHEST);
        shouldEnable();
        Config config = AnarchyExploitFixes.getConfiguration();
        config.addComment(configPath() + ".enable",
                "Should only affect server version 1.8 - 1.12.2.\n" +
                "Patches an exploit that allows players to track other players using location data\n" +
                "of specific entities like dropped items or lit TNT.\n" +
                "This is possible due to the server handling random events in a not so random way.\n" +
                "An in-depth explanation can be found here: https://github.com/spawnmason/randar-explanation\n" +
                "If you'd rather watch a video about it, FitMC covered it here: https://www.youtube.com/watch?v=maMpMOnIJDE\n" +
                "This solution is a tad bit hacky, its recommended to patch it inside paper instead if you know how to do it.\n" +
                "You can use leijurv's patch for that purpose:\n" +
                "https://github.com/spawnmason/PaperWithRandarPatched/commit/a5cd8a5a4b1e031201bbc60c0580bbabbc0ee5b7"
        );
        this.offsetBound = Math.abs(config.getDouble(configPath() + ".max-new-random-location-offset-blocks", 0.5));
        this.randoms_len = config.getInt(configPath() + ".how-many-randoms-should-we-use", 6,
                "How many Random objects to use for generating new entity spawn locations.\n" +
                        "One should technically be enough but theres no harm in making extra sure.");
        this.selector = new Random();
        this.randoms = new Random[randoms_len];
        for (int i = 0; i < randoms_len; i++) {
            randoms[i] = new Random();
        }
    }

    @Override
    public String configPath() {
        return "patches.prevent-randar-coordinate-exploit";
    }

    @Override
    public void enable() {
        PacketEvents.getAPI().getEventManager().registerListener(this);
    }

    @Override
    public void disable() {
        PacketEvents.getAPI().getEventManager().unregisterListener(this);
    }

    @Override
    public boolean shouldEnable() {
        return AnarchyExploitFixes.getConfiguration().getBoolean(configPath() + ".enable", PaperLib.getMinecraftVersion() <= 12);
    }

    @Override
    public void onPacketSend(PacketSendEvent event) {
        if (event.getPacketType() != PacketType.Play.Server.SPAWN_ENTITY) return;
        WrapperPlayServerSpawnEntity packet = new WrapperPlayServerSpawnEntity(event);
        Vector3d originalPosition = packet.getPosition();

        packet.setPosition(new Vector3d(
                ((int) originalPosition.x) + getNewOffset(),
                originalPosition.y,
                ((int) originalPosition.z) + getNewOffset()
        ));

        event.markForReEncode(true);
    }

    private double getNewOffset() {
        return (randoms_len <= 1 ? selector : randoms[selector.nextInt(randoms_len)]).nextDouble(-offsetBound, offsetBound);
    }
}
