package me.moomoo.anarchyexploitfixes.modules.packets;

import com.github.retrooper.packetevents.PacketEvents;
import com.github.retrooper.packetevents.event.PacketListenerPriority;
import com.github.retrooper.packetevents.event.PacketSendEvent;
import com.github.retrooper.packetevents.protocol.packettype.PacketType;
import com.github.retrooper.packetevents.wrapper.play.server.WrapperPlayServerSpawnEntity;
import io.papermc.lib.PaperLib;
import me.moomoo.anarchyexploitfixes.AnarchyExploitFixes;
import me.moomoo.anarchyexploitfixes.config.Config;

import java.util.Optional;
import java.util.Random;

public class RandarObfuscator extends AEFPacketModule {

    private final Random[] randoms;
    private final Random selector;
    private final double multiplierBound;
    private final int randomsLength;

    public RandarObfuscator() {
        super(PacketListenerPriority.HIGHEST);
        shouldEnable();
        Config config = AnarchyExploitFixes.getConfiguration();
        config.addComment(configPath() + ".enable",
                "Should only affect server version 1.8 - 1.12.2.\n" +
                "Patches an exploit that allows players to track other players using location data\n" +
                "of specific entities like dropped items or lit TNT.\n" +
                "This is possible due to the server handling random events in a not so random way.\n" +
                "An in-depth explanation can be found here: https://github.com/spawnmason/randar-explanation\n" +
                "If you'd rather watch a video about it, FitMC covered it here: https://www.youtube.com/watch?v=maMpMOnIJDE\n" +
                "ATTENTION: This solution is kinda hacky, its recommended to patch it inside paper or use a fork with\n" +
                "the patch already included (ex. dionysus). Should you want to patch it yourself, you can use the one by leijurv:\n" +
                "https://github.com/spawnmason/PaperWithRandarPatched/commit/a5cd8a5a4b1e031201bbc60c0580bbabbc0ee5b7");
        this.multiplierBound = Math.abs(config.getDouble(configPath() + ".max-position-multiplier", 0.00001,
                "To create new unique spawn locations and velocities without interfering with the games vanilla\n " +
                "functionality, we multiply them with a low random number.\n" +
                "Recommended to leave as is unless you experience abnormal behavior with entities in terms of\n" +
                "how or where they spawn."));
        this.randomsLength = config.getInt(configPath() + ".random-pool-size", 4,
                "How many Random objects to use for generating new entity spawn locations.\n" +
                "One should technically be enough but theres no harm in making extra sure.");
        this.selector = new Random();
        this.randoms = new Random[randomsLength];
        for (int i = 0; i < randomsLength; i++) {
            randoms[i] = new Random();
        }
    }

    @Override
    public String configPath() {
        return "patches.prevent-randar-coordinate-exploit";
    }

    @Override
    public void enable() {
        PacketEvents.getAPI().getEventManager().registerListener(this);
    }

    @Override
    public void disable() {
        PacketEvents.getAPI().getEventManager().unregisterListener(this);
    }

    @Override
    public boolean shouldEnable() {
        return AnarchyExploitFixes.getConfiguration().getBoolean(configPath() + ".enable", PaperLib.getMinecraftVersion() <= 12);
    }

    @Override
    public void onPacketSend(PacketSendEvent event) {
        if (event.getPacketType() != PacketType.Play.Server.SPAWN_ENTITY) return;

        WrapperPlayServerSpawnEntity packet = new WrapperPlayServerSpawnEntity(event);

        packet.setPosition(packet.getPosition().multiply(getRandomMultiplier()));
        if (packet.getVelocity().isPresent())
            packet.setVelocity(Optional.of(packet.getVelocity().get().multiply(getRandomMultiplier())));

        event.markForReEncode(true);
    }

    private double getRandomMultiplier() {
        return (randomsLength <= 1 ? selector : randoms[selector.nextInt(randomsLength)]).nextDouble(-multiplierBound, multiplierBound);
    }
}
