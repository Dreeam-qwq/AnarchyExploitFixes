package me.moomoo.anarchyexploitfixes.modules.packets;

import com.github.retrooper.packetevents.PacketEvents;
import com.github.retrooper.packetevents.event.PacketListenerPriority;
import com.github.retrooper.packetevents.event.PacketReceiveEvent;
import com.github.retrooper.packetevents.protocol.packettype.PacketType;
import com.github.retrooper.packetevents.wrapper.play.client.WrapperPlayClientPluginMessage;
import com.google.common.io.ByteStreams;
import me.moomoo.anarchyexploitfixes.AnarchyExploitFixes;
import me.moomoo.anarchyexploitfixes.config.Config;
import org.bukkit.Location;
import org.bukkit.entity.Player;
import org.bukkit.util.NumberConversions;

public class PurpurBeehiveCrash extends AEFPacketModule {

    private static final String BEEHIVE_C2S_CHANNEL = "purpur:beehive_c2s";
    private static final int SIZE_BITS_X = 26;
    private static final int SIZE_BITS_Z = SIZE_BITS_X;
    private static final int SIZE_BITS_Y = 64 - SIZE_BITS_X - SIZE_BITS_Z;
    private static final int BIT_SHIFT_Z = SIZE_BITS_Y;
    private static final int BIT_SHIFT_X = SIZE_BITS_Y + SIZE_BITS_Z;

    private final double maxDistanceSquared;
    private final boolean log, kick;

    public PurpurBeehiveCrash() {
        super(PacketListenerPriority.HIGHEST);
        shouldEnable();
        Config config = AnarchyExploitFixes.getConfiguration();
        config.addComment(configPath() + ".enable",
                "Patches a server crash exploit exclusive to Purpur servers.\n" +
                        "This exploit works due to PurpurClient having a feature that can request stored data\n" +
                        "of a clicked beehive from the server. The server does not check how far the clicked beehive\n" +
                        "is away from the player, enabling a malicious sender to load chunks very fast on random locations.");
        this.maxDistanceSquared = NumberConversions.square(config.getInt(configPath() + ".max-distance", 24));
        this.log = config.getBoolean(configPath() + ".log", false);
        this.kick = config.getBoolean(configPath() + ".kick-player", false);
    }

    @Override
    public String configPath() {
        return "patches.beehive-crash-patch";
    }

    @Override
    public void enable() {
        PacketEvents.getAPI().getEventManager().registerListener(this);
    }

    @Override
    public void disable() {
        PacketEvents.getAPI().getEventManager().unregisterListener(this);
    }

    @Override
    public boolean shouldEnable() {
        return AnarchyExploitFixes.getConfiguration().getBoolean(configPath() + ".enable", true);
    }

    @Override
    @SuppressWarnings("UnstableApiUsage")
    public void onPacketReceive(PacketReceiveEvent event) {
        if (event.getPacketType() != PacketType.Play.Client.PLUGIN_MESSAGE) return;
        WrapperPlayClientPluginMessage packet = new WrapperPlayClientPluginMessage(event);
        if (!packet.getChannelName().equalsIgnoreCase(BEEHIVE_C2S_CHANNEL)) return;

        Player player = (Player) event.getPlayer();
        if (player == null) return;

        if (distanceSquared(ByteStreams.newDataInput(packet.getData()).readLong(), player.getLocation()) > maxDistanceSquared) {
            event.setCancelled(true);
            onCancel(log, kick, event.getUser());
        }
    }

    private double distanceSquared(long packedBlockPos, final Location playerPos) {
        return  NumberConversions.square(unpackLongX(packedBlockPos) - playerPos.getX()) +
                NumberConversions.square(unpackLongY(packedBlockPos) - playerPos.getY()) +
                NumberConversions.square(unpackLongZ(packedBlockPos) - playerPos.getZ());
    }

    private int unpackLongX(long packedPos) {
        return (int)(packedPos << 64 - BIT_SHIFT_X - SIZE_BITS_X >> 64 - SIZE_BITS_X);
    }

    private int unpackLongY(long packedPos) {
        return (int)(packedPos << 64 - SIZE_BITS_Y >> 64 - SIZE_BITS_Y);
    }

    private int unpackLongZ(long packedPos) {
        return (int)(packedPos << 64 - BIT_SHIFT_Z - SIZE_BITS_Z >> 64 - SIZE_BITS_Z);
    }
}
